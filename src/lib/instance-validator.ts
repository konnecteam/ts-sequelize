'use strict';

import * as _ from 'lodash';
import DataTypes from './data-types';
import * as sequelizeError from './errors/index';
import { Model } from './model';
import Promise from './promise';
import * as AllUtils from './utils';
import * as validatorExtras from './utils/validator-extras';

const extendModelValidations = validatorExtras.extendModelValidations;
const validator = validatorExtras.validator;
/**
 * The Main Instance Validator.
 *
 * @param modelInstance The model instance.
 * @param options A dict with options.
 */
export class InstanceValidator {
  public options : {
    defaultFields? : string[],
    fields? : string[],
    /** An object of hook function that are called before and after certain lifecycle events */
    hooks? : boolean,
    returning? : boolean,
    skip? : any[],
    validate? : boolean
  };
  public modelInstance : Model;
  /** Exposes a reference to validator.js. This allows you to add custom validations using `validator.extend`
   * @private validator
   */
  public validator;
  /**
   *  All errors will be stored here from the validations.
   *  Will contain keys that correspond to attributes which will be Arrays of Errors.
   */
  private errors : sequelizeError.ValidationErrorItem[];
  /** Indicates if validations are in progress */
  private inProgress : boolean;
  public static RAW_KEY_NAME : string;


  constructor(modelInstance? : Model, options? : { fields?, skip?, hooks? }) {
    options = _.clone(options) || {};

    if (options.fields && !options.skip) {
      options.skip = _.difference(Object.keys(modelInstance.constructor.rawAttributes), options.fields);
    }

    // assign defined and default options
    this.options = _.defaults(options, {
      skip: [],
      hooks: true
    });

    this.modelInstance = modelInstance;

    this.validator = validator;

    this.errors = [];

    this.inProgress = false;

    extendModelValidations(modelInstance);
  }

  /**
   * The main entry point for the Validation module, invoke to start the dance.
   * @hidden
   */
  private _validate() : Promise<any> {
    if (this.inProgress) {
      throw new Error('Validations already in progress.');
    }
    this.inProgress = true;

    return Promise.all(
      [this._builtinValidators(), this._customValidators()].map(promise => promise.reflect())
    ).then(() => {
      if (this.errors.length) {
        throw new sequelizeError.ValidationError(null, this.errors);
      }
    });
  }

  /**
   * Invoke the Validation sequence and run validation hooks if defined
   *   - Before Validation Model Hooks
   *   - Validation
   *   - On validation success: After Validation Model Hooks
   *   - On validation failure: Validation Failed Model Hooks
   */
  public validate() : Promise<any> {
    return this.options.hooks ? this._validateAndRunHooks() : this._validate();
  }

  /**
   * Invoke the Validation sequence and run hooks
   *   - Before Validation Model Hooks
   *   - Validation
   *   - On validation success: After Validation Model Hooks
   *   - On validation failure: Validation Failed Model Hooks
   */
  public _validateAndRunHooks() : Promise<any> {
    const runHooks = this.modelInstance.constructor.runHooks.bind(this.modelInstance.constructor);
    return runHooks('beforeValidate', this.modelInstance, this.options)
      .then(() =>
        this._validate()
          .catch(error => runHooks('validationFailed', this.modelInstance, this.options, error)
            .then(newError => { throw newError || error; }))
      )
      .then(() => runHooks('afterValidate', this.modelInstance, this.options))
      .return(this.modelInstance);
  }

  /**
   * Will run all the built-in validators.
   *
   * @returns Promise(Array.<Promise.PromiseInspection>), A promise from .reflect().
   * @hidden
   */
  private _builtinValidators() : any {
    // promisify all attribute invocations
    const validators = [];
    _.forIn(this.modelInstance.rawAttributes, (rawAttribute, field) => {
      if (this.options.skip.indexOf(field) >= 0) {
        return;
      }

      const value = this.modelInstance.dataValues[field];

      if (!rawAttribute['_autoGenerated'] && !rawAttribute['autoIncrement']) {
        // perform validations based on schema
        this._validateSchema(rawAttribute, field, value);
      }

      if (this.modelInstance.validators.hasOwnProperty(field)) {
        validators.push(this._builtinAttrValidate.call(this, value, field).reflect());
      }
    });

    return Promise.all(validators);
  }

  /**
   * Will run all the custom validators.
   *
   * @returns Promise(Array.<Promise.PromiseInspection>), A promise from .reflect().
   * @hidden
   */
  private _customValidators() : any {
    const validators = [];
    Object.keys(this.modelInstance._modelOptions.validate).forEach(validatorType => {
      const customValidator = this.modelInstance._modelOptions.validate[validatorType];
      if (this.options.skip.indexOf(validatorType) >= 0) {
        return;
      }

      const valprom = this._invokeCustomValidator(customValidator, validatorType)
        // errors are handled in settling, stub this
        .catch(() => {})
        .reflect();

      validators.push(valprom);
    });

    return Promise.all(validators);
  }

  /**
   * Validate a single attribute with all the defined built-in validators.
   *
   * @param value Anything.
   * @param field The field name.
   * @returns A promise, will always resolve, auto populates error on this.error local object.
   * @hidden
   */
  private _builtinAttrValidate(value : any, field : string) : Promise<any> {
    // check if value is null (if null not allowed the Schema pass will capture it)
    if (value == null) {
      return Promise.resolve();
    }

    // Promisify each validator
    const validators = [];
    _.forIn(this.modelInstance.validators[field], (test, validatorType) => {

      if (['isUrl', 'isURL', 'isEmail'].indexOf(validatorType) !== -1) {
        // Preserve backwards compat. Validator.js now expects the second param to isURL and isEmail to be an object
        if (typeof test === 'object' && test !== null && test.msg) {
          test = {
            msg: test.msg
          };
        } else if (test === true) {
          test = {};
        }
      }

      // Check for custom validator.
      if (typeof test === 'function') {
        return validators.push(this._invokeCustomValidator(test, validatorType, true, value, field).reflect());
      }

      const validatorPromise = this._invokeBuiltinValidator(value, test, validatorType, field);
      // errors are handled in settling, stub this
      validatorPromise.catch(() => {});
      validators.push(validatorPromise.reflect());
    });

    return Promise
      .all(validators)
      .then(results => this._handleReflectedResult(field, value, results));
  }

  /**
   * Prepare and invoke a custom validator.
   *
   * @param validator : Function, The custom validator.
   * @param validatorType the custom validator type (name).
   * @param optAttrDefined Set to true if custom validator was defined from the Attribute
   * @returns Promise, A promise.
   * @hidden
   */
  private _invokeCustomValidator(customValidator : any, validatorType : string, optAttrDefined? : boolean, optValue? : boolean, optField? : string) : any {
    let validatorFunction = null;  // the validation function to call
    let isAsync = false;

    const validatorArity = customValidator.length;
    // check if validator is async and requires a callback
    let asyncArity = 1;
    let errorKey = validatorType;
    let invokeArgs;
    if (optAttrDefined) {
      asyncArity = 2;
      invokeArgs = optValue;
      errorKey = optField;
    }
    if (validatorArity === asyncArity) {
      isAsync = true;
    }

    if (isAsync) {
      if (optAttrDefined) {
        validatorFunction = Promise.promisify(customValidator.bind(this.modelInstance, invokeArgs));
      } else {
        validatorFunction = Promise.promisify(customValidator.bind(this.modelInstance));
      }
      return validatorFunction()
        .catch(e => this._pushError(false, errorKey, e, optValue, validatorType));
    } else {
      return Promise
        .try(() => customValidator.call(this.modelInstance, invokeArgs))
        .catch(e => this._pushError(false, errorKey, e, optValue, validatorType));
    }
  }

  /**
   * Prepare and invoke a build-in validator.
   *
   * @param value Anything.
   * @param test The test case.
   * @param validatorType One of known to Sequelize validators.
   * @param field The field that is being validated
   * @returns An object with specific keys to invoke the validator.
   */
  private _invokeBuiltinValidator(value : any, test : any, validatorType : string, field : string) : any {
    return Promise.try(() => {
      // Cast value as string to pass new Validator.js string requirement
      const valueString = String(value);
      // check if Validator knows that kind of validation test
      if (typeof validator[validatorType] !== 'function') {
        throw new Error('Invalid validator function: ' + validatorType);
      }

      const validatorArgs = this._extractValidatorArgs(test, validatorType, field);

      if (!validator[validatorType].apply(validator, [valueString].concat(validatorArgs))) {
        throw Object.assign(new Error(test.msg || `Validation ${validatorType} on ${field} failed`), { validatorName: validatorType, validatorArgs });
      }
    });
  }

  /**
   * Will extract arguments for the validator.
   *
   * @param test The test case.
   * @param validatorType One of known to Sequelize validators.
   * @param field The field that is being validated.
   * @hidden
   */
  private _extractValidatorArgs(test : any, validatorType : string, field : string) : any {
    let validatorArgs = test.args || test;
    const isLocalizedValidator = typeof validatorArgs !== 'string' && (validatorType === 'isAlpha' || validatorType === 'isAlphanumeric' || validatorType === 'isMobilePhone');

    if (!Array.isArray(validatorArgs)) {
      if (validatorType === 'isImmutable') {
        validatorArgs = [validatorArgs, field];
      } else if (isLocalizedValidator || validatorType === 'isIP') {
        validatorArgs = [];
      } else {
        validatorArgs = [validatorArgs];
      }
    } else {
      validatorArgs = validatorArgs.slice(0);
    }
    return validatorArgs;
  }

  /**
   * Will validate a single field against its schema definition (isnull).
   *
   * @param rawAttribute As defined in the Schema.
   * @param field The field name.
   * @param value anything.
   * @hidden
   */
  private _validateSchema(rawAttribute : { allowNull? : boolean, type? }, field : string, value : any) {
    if (rawAttribute.allowNull === false && (value === null || value === undefined)) {
      const validators = this.modelInstance.validators[field];
      const errMsg = _.get(validators, 'notNull.msg', `${this.modelInstance.constructor.name}.${field} cannot be null`);

      this.errors.push(new sequelizeError.ValidationErrorItem(
        errMsg,
        'notNull Violation', // sequelizeError.ValidationErrorItem.Origins.CORE,
        field,
        value,
        this.modelInstance,
        'is_null'
      ));
    }

    if (rawAttribute.type === DataTypes.STRING || rawAttribute.type instanceof DataTypes.STRING || rawAttribute.type === DataTypes.TEXT || rawAttribute.type instanceof DataTypes.TEXT) {
      if (Array.isArray(value) || _.isObject(value) && !(value instanceof AllUtils.SequelizeMethod) && !Buffer.isBuffer(value)) {
        this.errors.push(new sequelizeError.ValidationErrorItem(
          `${field} cannot be an array or an object`,
          'string violation', // sequelizeError.ValidationErrorItem.Origins.CORE,
          field,
          value,
          this.modelInstance,
          'not_a_string'
        ));
      }
    }
  }


  /**
   * Handles the returned result of a Promise.reflect.
   *
   * If errors are found it populates this.error.
   *
   * @param field The attribute name.
   * @param value The data value.
   * @param Promise : Array.<Promise.PromiseInspection>, inspection objects.
   * @hidden
   */
  private _handleReflectedResult(field : string, value : string | number, promiseInspections) {
    for (const promiseInspection of promiseInspections) {
      if (promiseInspection.isRejected()) {
        const rejection = promiseInspection.error();
        const isBuiltIn = !!rejection.validatorName;

        this._pushError(isBuiltIn, field, rejection, value, rejection.validatorName, rejection.validatorArgs);
      }
    }
  }

  /**
   * Signs all errors retaining the original.
   *
   * @param isBuiltin   - Determines if error is from builtin validator.
   * @param errorKey    - name of invalid attribute.
   * @param rawError    - The original error.
   * @param value       - The data that triggered the error.
   * @param fnName      - Name of the validator, if any
   * @param fnArgs      - Arguments for the validator [function], if any
   * @hidden
   */
  private _pushError(isBuiltin : boolean, errorKey : string, rawError : Error | string, value : any, fnName : string, fnArgs? : any[]) {
    const message = (rawError as any).message || rawError || 'Validation error';
    const error = new sequelizeError.ValidationErrorItem(
      message,
      'Validation error', // sequelizeError.ValidationErrorItem.Origins.FUNCTION,
      errorKey,
      value,
      this.modelInstance,
      fnName,
      isBuiltin ? fnName : undefined,
      isBuiltin ? fnArgs : undefined
    );

    error[InstanceValidator.RAW_KEY_NAME] = rawError;

    this.errors.push(error);
  }
}
/**
 * @define {string} The error key for arguments as passed by custom validators
 */
InstanceValidator.RAW_KEY_NAME = '__raw';
